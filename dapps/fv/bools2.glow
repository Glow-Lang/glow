#lang glow
// TODO: insert escrow in a compiler pass
@interaction([A, B])
let coinFlip = (x : Nat, flag : Bool) => {

   @A assert! (canReach(branch1) OR canReach(branch2));
   // @A assert! canReach(branch1);
   @B assert! canReach(branch1);
   // @A assert! canReach(branch2);
   @B assert! canReach(branch2);
   
   @A let bA = input(Bool, "Enter A's parameter:");
   @B let bB = input(Bool, "Enter B's parameter:");
   @B let bBB = input(Bool, "Enter B's second parameter:");

   let someBoolVal = false;

   publish! A -> bA;
   publish! B -> bB;
   publish! B -> bBB;

   deposit! A -> x;
   deposit! B -> x;

   let someBoolVal2 = bBB && flag;

    switch (((bA && bB) && flag) || bBB) {
      | true => let zz = 2 ; branch1 : withdraw! A <- 2*x
                
      | false => let zz = 2 ; branch2 : withdraw! B <- 2*x  };

   //  if (((bA && bB) && flag) || bBB) {
   //      branch1 : withdraw! A <- 2*x;
   //  }
   //  else {
   //         if (((bA && bB) && flag) || bBB) {        
   //             branch11 : withdraw! A <- 2*x;
   //         }
   //         else {
   //             branch22 : withdraw! B <- 2*x;
   //         }
   //      // branch2 : withdraw! B <- 2*x;
   // }


    // branch12 : withdraw! A <- 2*x;

    let z = switch (x) {
      | 1 => let zz = 2 ; 11
      
      | 2 => let zz = 2 ; 22
      | _ => let zz = 2 ; 33
      };

    switch (((bA && (z == 22)) && flag) || someBoolVal2) {
      | true => branch11 : withdraw! A <- 2*x
      
      | false => branch22 : withdraw! B <- 2*x  };

};
