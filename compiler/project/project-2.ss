(export project-2)

(import :std/format :std/iter :std/stxutil
        :std/misc/list :std/sort :std/srfi/1
        (only-in :std/misc/rbtree symbol-cmp)
        <expander-runtime>
        (for-template :mukn/glow/compiler/syntax-context)
        :mukn/glow/compiler/syntax-context
        :mukn/glow/compiler/common
        :mukn/glow/compiler/alpha-convert/fresh
        :mukn/glow/compiler/checkpointify/checkpointify
        :mukn/glow/compiler/typecheck/type
        :mukn/glow/compiler/typecheck/stx-prop
        :mukn/glow/compiler/method-resolve/method-resolve
        :clan/base
        :clan/pure/dict/assq
        :clan/pure/dict/symdict
        ./translate-pure)

;; project-2 : ModuleStx UnusedTable TypeTable TysymMethodsTable MethodsIdBackTable CheckpointInfoTable -> [Listof SchemeStx]
;; Expect:
;;   exactly 1 (def id (@make-interacation ((@list participant ...)) . _))
;;   any number of non-def-interaction staments
(def (project-2 prog unused tytbl tymetbl mebatbl cpit)
  (parameterize ((current-unused-table unused)
                 (current-has-type-table tytbl)
                 (current-tysym-methods-table tymetbl)
                 (current-methods-id-back-table mebatbl))
   (syntax-case prog (@module)
     ((@module (begin end) stmt ...)
      (let ((stmts (syntax->list #'(stmt ...))))
        (cons*
          #'(export #t)
          #'(import :mukn/glow/compiler/project/runtime-2)
          (translate-body stmts cpit #f)))))))

;; stx-def-interaction? : Stx -> Bool
;; stx-not-def-interaction? : Stx -> Bool
(def (stx-def-interaction? stx)
  (syntax-case stx (def @make-interaction)
    ((def _ (@make-interaction . _)) #t)
    (_ #f)))
(def (stx-not-def-interaction? stx) (not (stx-def-interaction? stx)))

;; stx-def-interaction-name : StmtStx -> Identifier
(def (stx-def-interaction-name stx)
  (syntax-case stx (def @make-interaction)
    ((def name (@make-interaction . _)) #'name)))

;; stx-def-interaction-participants : StmtStx -> [Listof Symbol]
(def (stx-def-interaction-participants stx)
  (syntax-case stx (def @make-interaction @list)
    ((def _ (@make-interaction ((@list p ...)) . _))
     (syntax->datum #'(p ...)))))

;; stx-def-interaction-parameter-names : StmtStx -> [Listof Identifier]
(def (stx-def-interaction-parameter-names stx)
  (syntax-case stx (def @make-interaction @list)
    ((def _ (@make-interaction _ params . _))
     (stx-map head-id #'params))))

;; --------------------------------------------------------

;; translate-def-interaction : StmtStx CpiTable MPart -> [Listof SchemeStx]
(def (translate-def-interaction stx cpit this-p)
  (assert! (not this-p) "`@make-interaction` is only allowed in the consensus")
  (def name (stx-def-interaction-name stx))
  (def participants (stx-def-interaction-participants stx))
  (def parameters (stx-def-interaction-parameter-names stx))
  (def name-consensus (identifier-fresh (format-id name "~a-consensus" name)))
  (def name-participants
    (for/collect ((p participants)) (identifier-fresh (format-id name "~a-~a" name p))))
  (syntax-case stx (def @make-interaction @list)
    ((def _ (@make-interaction _ _ _ . projs))
     (let ((projs (stx-map (lambda (p) (match (syntax->list p) ([k . v] [(stx-e k) . v]))) #'projs)))
       (def consensus-body (assq-ref projs #f))
       (def participant-bodys (map (cut assq-ref projs <>) participants))
       (append
        [(translate-interaction-proj #f name-consensus participants parameters consensus-body cpit)]
        (for/collect ((p participants) (name-p name-participants) (b participant-bodys))
          (translate-interaction-proj p name-p participants parameters b cpit))
        [(connect-def-interaction-projections name participants parameters name-consensus name-participants)])))))

;; translate-interaction-proj : MPart Id [Listof Participant] [Listof Id] [Listof StmtStx] CpiTable -> SchemeStx
(def (translate-interaction-proj this-p name participants parameters body cpit)
  (def in (symbol-fresh 'in))
  (def out (symbol-fresh 'out))
  ['def name
    ['lambda [in out participants ...]
      ['lambda parameters
        ['parameterize [['current-input-channel in] ['current-output-channel out]]
          ['begin0
            (cons* 'let [] (translate-body body cpit this-p))
            (cond (this-p #'(participant:end-interaction))
                  (else   #'(consensus:end-interaction)))]]]]])

;; connect-def-interaction-projections :
;; Id [Listof Sym] [Listof Id] Id [Listof Id] -> SchemeStx
;; `name` is the name of the interaction,
;; each `participant` is the name of a participant,
;; each `parameter` is an argument to the interaction function
;; `name-consensus` is the consensus-projection of the interaction,
;; and each `name-participant` is a participant-projection of the interaction,
;;   the name of a function generated by `project-def-interaction`.
(def (connect-def-interaction-projections name participants parameters name-consensus name-participants)
  (with-syntax ((name name)
                ((p ...) participants)
                ((x ...) parameters)
                (name-consensus name-consensus)
                ((name-participant ...) name-participants)
                ((consensus->participant ...) (map (cut format-id #'consensus "consensus->~a" <>) participants)))
    #'(def ((name p ...) x ...)
        ;; each p is an address passed in by the caller
        ;; consensus->participant ... : Channel
        ;; consensus->participants : [Listof Channel]
        (def consensus->participant (make-channel #f)) ...
        (def consensus->participants [consensus->participant ...])
        ;; participant->consensus : Channel
        (def participant->consensus (make-channel #f))
        ;; balances : [Dicteqof Address Nat]
        (def balances (get-balances [p ...]))
        (def consensus-thread
          (spawn/name/params 'consensus
            (lambda ()
              (parameterize ((current-address #f)
                             (current-balances balances))
                ((name-consensus participant->consensus consensus->participants p ...) x ...)))))
        (def participant-threads
          [(spawn/name/params 'p
            (lambda ()
              (parameterize ((current-address p)
                             (current-balances balances))
                ((name-participant consensus->participant participant->consensus p ...) x ...))))
           ...])
        (for-each thread-join! (cons consensus-thread participant-threads))
        (channel-close consensus->participant) ...
        (channel-close participant->consensus)
        'done)))


;; translate-body : [Listof StmtStx] CpiTable MPart -> [Listof SchemeStx]
(def (translate-body stmts cpit this-p)
  (flatten1 (stx-map (cut translate-stmt <> cpit this-p) stmts)))

;; translate-stmt : StmtStx CpiTable MPart -> [Listof SchemeStx]
(def (translate-stmt stx cpit this-p)
  (syntax-case stx (@ @label @debug-label @make-interaction
                    consensus:set-participant participant:set-participant
                    consensus:withdraw participant:withdraw
                    expect-published expect-deposited
                    add-to-publish add-to-deposit
                    deftype defdata publish! def ann return ignore! switch require! assert! deposit! withdraw!)
    ;; TODO: ignore @label whether pure or not
    ((@label x) [])
    ((@debug-label x) [])
    ((def _ (@make-interaction . _)) (translate-def-interaction stx cpit this-p))
    ((def _ (expect-published . _)) (translate-def-expect-published stx cpit this-p))
    ((consensus:set-participant . _) [stx])
    ((participant:set-participant . _) [stx])
    ((consensus:withdraw . _) [stx])
    ((participant:withdraw . _) [stx])
    ((expect-published . _) [stx])
    ((expect-deposited . _) [stx])
    ((add-to-publish . _) (translate-add-to-publish stx cpit this-p))
    ((add-to-deposit . _) [stx])
    ((require! v) (translate-require stx cpit this-p))
    ((assert! v) (translate-assert stx cpit this-p))
    ((switch c cases ...) (translate-switch stx cpit this-p))
    ((def v e) (translate-pure-stmt stx))
    ((ignore! e) (translate-pure-stmt stx))
    ((return e) (translate-pure-stmt stx))
    ((defdata . _) (translate-pure-stmt stx))
    ((deftype . _) (translate-pure-stmt stx))
    ;; NB: after ANF, p e v below are guaranteed identifiers
    ((ann v _) (translate-pure-stmt stx))))

;; translate-set-participant : Id CpiTable MPart -> SchemeStx
(def (translate-set-participant p cpit this-p)
  (cond
    (this-p [#'participant:set-participant p])
    (else   [#'consensus:set-participant p])))

;; translate-add-to-publish : StmtStx CpiTable MPart -> [Listof SchemeStx]
(def (translate-add-to-publish stx cpit this-p)
  (syntax-case stx ()
    ((_ sym x)
     (with-syntax ((t (expr-type-methods-expr #'x)))
       [#'(add-to-publish sym x t)]))))

;; translate-def-expect-published : StmtStx CpiTable MPart -> [Listof SchemeStx]
(def (translate-def-expect-published stx cpit this-p)
  (syntax-case stx (def expect-published)
    ((def x (expect-published sym))
     (with-syntax ((t (expr-type-methods-expr #'x)))
       [#'(def x (expect-published sym t))]))))

;; translate-deposit : StmtStx CpiTable MPart -> [Listof SchemeStx]
(def (translate-deposit stx cpit this-p)
  (syntax-case stx ()
    ((_ p n)
     [(translate-set-participant #'p cpit this-p)
      (cond
        ((eq? (stx-e #'p) this-p) #'(add-to-deposit p n))
        (else #'(expect-deposited p n)))])))

;; translate-require : StmtStx CpiTable MPart -> [Listof SchemeStx]
(def (translate-require stx cpit this-p)
  (syntax-case stx (require!)
    ;; TODO: use exceptions that enable the backtracking on failure
    ;; TODO: provide compile-time srclocs for runtime handler
    ;; TODO: add participant and translate-set-participant
    ((require! x) [#'(assert! x)])))

;; translate-assert : StmtStx CpiTable MPart -> [Listof SchemeStx]
(def (translate-assert stx cpit this-p)
  (syntax-case stx (assert!)
    ;; TODO: use exceptions that enable the backtracking on failure
    ;; TODO: provide compile-time srclocs for runtime handler
    ((assert! x) [#'(assert! x)])))

;; translate-switch : StmtStx CpiTable MPart -> [Listof SchemeStx]
(def (translate-switch stx cpit this-p)
  (syntax-case stx ()
    ((switch c cases ...)
     [(restx1 stx
              (cons* 'match (translate-pure-expr #'c)
                     (stx-map (cut translate-switch-case <> cpit this-p) #'(cases ...))))])))

;; translate-switch-case : SwcaseStx CpiTable MPart -> SchemeStx
(def (translate-switch-case stx cpit this-p)
  (syntax-case stx ()
    ((pat body ...)
     (restx stx
            (cons (translate-switch-pat #'pat)
                  (translate-body #'(body ...) cpit this-p))))))
