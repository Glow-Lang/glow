{-# OPTIONS --cubical  #-}
module Glow.Simple.Lurk.StatesPrimPrim where

open import Agda.Builtin.String
open import Agda.Builtin.Char
-- open import Agda.Builtin.List

open import Cubical.Foundations.Everything 

open import Cubical.Data.Nat renaming (_+_ to _‚Ñï+_)
open import Cubical.Data.Fin
open import Cubical.Data.Int
open import Cubical.Data.Prod
open import Cubical.Data.Sum renaming (elim to sum-elim ; rec to sum-rec ; map to sum-map)
open import Cubical.Data.List renaming (map to map-List)


open import Cubical.Data.Maybe renaming (rec to recMaybe)
open import Cubical.Data.Bool hiding (if_then_else_)  renaming (Bool to ùüö)

open import Cubical.Data.Empty renaming (elim to empty-elim ; rec to empty-rec ;  ‚ä• to Empty )


open import Cubical.Data.Nat.Order.Recursive
-- open import Cubical.Functions.Logic

open import Cubical.Relation.Nullary.Base renaming (¬¨_ to IsEmpty)

open import Glow.Linked

open import Glow.Simple.AST

open import Glow.DecEqMore

open import Glow.Simple.ContextMore

open import Glow.Simple.VarSubst

open import Glow.Simple.ParamsSubst

-- open import Glow.Simple.Monad


open import Cubical.HITs.Interval

open import Glow.ListDecProps

open import Cubical.Categories.Category

module _ {Identifier : Type‚ÇÄ} {{IsDiscrete-Identifier : IsDiscrete Identifier}}
            {BuilitInsIndex : Type‚ÇÄ} {{IsDiscrete-BuilitInsIndex : IsDiscrete BuilitInsIndex}}
              {builtIns : BuiltIns' BuilitInsIndex {{IsDiscrete-BuilitInsIndex}}} where


  module TraceNice {ptpsIds : List (Identifier)} where

    ptps : List (Identifier √ó ParticipantModality)
    ptps = map-List (_, dishonest) ptpsIds
    
    module _ {uniquePtps : _} where
    
      open AST.InteractionHead {Identifier} {builtIns = builtIns} {one} (AST.interactionHead ptps [] {_} {uniquePtps}) 



      open SubstAll {Identifier} {builtIns = builtIns} {ptps = ptps}
      open SubstOne {Identifier} {builtIns = builtIns} {ptps = ptps}

   -- Context :   (A : Int) :: (B : Int) :: (C : Bool) :: []
   --             (A : 3)   :: (B : 2) :: (C : True ) :: []



   -- PublicContext : (A : Int ) :: { ( (B : Int) :: (C : Int)  ) , (D : Int)  } :: []
   --                 (A : 3) :: ( B : 2) :: (C : 4) :: []
   --                 (A : 2) :: (D : 4) :: []


      data PublicContext : Type‚ÇÄ where
        PC[] : PublicContext
        _PC‚à∑_ : (GType) ‚äé (PublicContext √ó PublicContext) ‚Üí PublicContext ‚Üí PublicContext 
        -- ‚ü®_‚à∂_‚ü©PC‚à∑_ : Identifier ‚Üí GType ‚Üí PublicContext ‚Üí PublicContext
        -- [_‚à®_]bPC‚à∑_ : PublicContext ‚Üí PublicContext ‚Üí PublicContext ‚Üí PublicContext

      {-# TERMINATING #-}
      PCRec : PublicContext ‚Üí Type‚ÇÄ
      PCRec PC[] = Unit
      PCRec (x PC‚à∑ x‚ÇÅ) = (sum-elim GTypeAgdaRep (Œª b ‚Üí PCRec (proj‚ÇÅ b) ‚äé PCRec (proj‚ÇÇ b)) x) √ó PCRec x‚ÇÅ 

      _PC++_ : PublicContext ‚Üí PublicContext ‚Üí PublicContext
      _PC++_ PC[] x‚ÇÅ = x‚ÇÅ
      _PC++_ (x PC‚à∑ x‚ÇÇ) x‚ÇÅ = x PC‚à∑ (x‚ÇÇ PC++  x‚ÇÅ)
      
      StmntPC : ‚àÄ {Œì} ‚Üí Stmnt Œì ‚Üí PublicContext

      StatementsPC : ‚àÄ {Œì} ‚Üí Statements Œì ‚Üí PublicContext
      ExprPC : ‚àÄ {Œì Œ§} ‚Üí Expr Œì Œ§ ‚Üí PublicContext

      StatementsPC []L = PC[]
      StatementsPC (h ‚à∑L x) = StmntPC h  PC++ StatementsPC x 

      ExprPC (AST.var x) = PC[]
      ExprPC (AST.body (AST.bodyR stmnts‚ÇÅ expr‚ÇÅ)) = StatementsPC stmnts‚ÇÅ PC++ ExprPC expr‚ÇÅ
      ExprPC (AST.lit x) = PC[]
      ExprPC (x AST.$' x‚ÇÅ) = PC[]
      ExprPC (AST.input x) = PC[]
      ExprPC (AST.sign x) = PC[]
      ExprPC {Œ§ = Œ§} (AST.receivePublished x) = inl (Œ§) PC‚à∑ PC[]
      ExprPC (AST.if x then x‚ÇÅ else x‚ÇÇ) = inr (ExprPC x‚ÇÅ , ExprPC x‚ÇÇ) PC‚à∑ PC[]

      StmntPC {Œì} (AST.bindingS x) = w x
         where
          w : BStmnt Œì ‚Üí PublicContext
          w (AST.BS-let ce x) = ExprPC x
          w (AST.BS-publish! p x) = PC[] 
      StmntPC {Œì} (AST.nonBindingS (AST.stmntNBS x)) = PC[]
        -- where
        --   w : NBStmnt Œì ‚Üí PublicContext
        --   w (AST.NBS-require! x) = PC[]
        --   w (AST.NBS-deposit! x x‚ÇÅ) = PC[]
        --   w (AST.NBS-withdraw! x x‚ÇÅ) = PC[]
        --   w (AST.NBS-publishVal! x x‚ÇÅ) = PC[] -- <- imposible!!
      StmntPC {Œì} (AST.nonBindingS (AST.exprNBS x)) = ExprPC x

      -- evalWithPC : ‚àÄ {Œì Œ§} ‚Üí (e : Expr Œì Œ§) ‚Üí (r : Rec Œì) ‚Üí PCRec (ExprPC e) ‚Üí GTypeAgdaRep Œ§
      -- evalWithPC = {!!}

      -- evalWithPC : ‚àÄ {Œ§} ‚Üí (e : Expr (con [] nothing) Œ§) ‚Üí PCRec (ExprPC e) ‚Üí GTypeAgdaRep Œ§
      -- evalWithPC e x = {!!}


      record PCExpr (pc : PublicContext) (Œ§ : GType) : Type‚ÇÄ where
        field
           e : Expr (con [] nothing) Œ§
           pc‚â° : ExprPC e ‚â° pc

      data Action (pc : PublicContext) : Type‚ÇÄ where
        withdrawA : PCExpr pc Nat ‚Üí Action pc
        depositA : PCExpr pc Nat ‚Üí Action pc 
        publishA : Identifier ‚Üí GType ‚Üí Action pc

      AMM : (A : Type‚ÇÄ) ‚Üí PublicContext ‚Üí  Type‚ÇÄ 
      MMM : PublicContext ‚Üí  Type‚ÇÄ 
      data MM (A : Type‚ÇÄ) (pc : PublicContext) : Type‚ÇÄ where
         guardMM : A ‚Üí DishonestParticipantId ‚Üí PCExpr pc Bool ‚Üí Action pc ‚Üí MM A pc
         branchMM : PCExpr pc Bool ‚Üí AMM A pc ‚Üí AMM A pc ‚Üí MM A pc


      -- publicBindingPart : ‚àÄ pc ‚Üí MM pc ‚Üí PublicContext
      -- publicBindingPart pc (guardMM x (withdrawA x‚ÇÅ)) = PC[]
      -- publicBindingPart pc (guardMM x (depositA x‚ÇÅ)) = PC[]
      -- publicBindingPart pc (guardMM x (publishA x‚ÇÅ x‚ÇÇ)) = inl (x‚ÇÇ) PC‚à∑ PC[]
      -- publicBindingPart pc (branchMM x x‚ÇÅ x‚ÇÇ) = 
      --    inr ({!!} , {!!}) PC‚à∑ PC[]

      {-# TERMINATING #-}
      publicBinding : ‚àÄ {A} ‚Üí ‚àÄ pc ‚Üí MM A pc ‚Üí PublicContext

      AMM A = Linked' (publicBinding {A})


      MMM = Linked' (publicBinding {Unit})

      NMM = Linked' (publicBinding {‚Ñï})

      publicBinding pc (guardMM _ _ x (withdrawA x‚ÇÅ)) = PC[]
      publicBinding pc (guardMM _ _ x (depositA x‚ÇÅ)) = PC[]
      publicBinding pc (guardMM _ _ x (publishA x‚ÇÅ x‚ÇÇ)) = inl (x‚ÇÇ) PC‚à∑ PC[] 
      publicBinding pc (branchMM x x‚ÇÅ x‚ÇÇ) =
         inr (foldLinked' x‚ÇÅ , foldLinked' x‚ÇÇ) PC‚à∑ PC[]

      CC : ‚àÄ {_ : Type‚ÇÄ} ‚Üí Category ‚Ñì-zero ‚Ñì-zero
      CC {A} = FreeCategory' {C = PublicContext} {A = MM A} publicBinding {!!} {!!}




      -- testMMM : MMM PC[]
      -- testMMM = guardMM {!!} (publishA {!!} Nat) ‚à∑L ({!!}  ‚à∑L []L)

      mkGuard : (ss : Statements (con [] nothing)) ‚Üí PCExpr (StatementsPC ss) Bool
      mkGuard = {!!}

      evalViaPublic : ‚àÄ {Œ§} ‚Üí (ss : Statements (con [] nothing)) ‚Üí Expr (foldLinked' ss) Œ§ ‚Üí PCExpr (StatementsPC ss) Œ§ 
      evalViaPublic = {!!}

      {-# TERMINATING #-}
      sliceMM : (ss : Statements (con [] nothing))
                ‚Üí Statements (foldLinked' ss)
                ‚Üí MMM (StatementsPC ss)
      sliceMM ss []L = []L
      sliceMM ss (h ‚à∑L []L) = w h
         where

          w'' : NBStmnt (foldLinked' ss) ‚Üí Maybe (Action (StatementsPC ss))
          w'' (AST.NBS-require! x) = nothing
          w'' (AST.NBS-deposit! x x‚ÇÅ) = just (depositA (evalViaPublic ss x‚ÇÅ))
          w'' (AST.NBS-withdraw! x x‚ÇÅ) = just (withdrawA (evalViaPublic ss x‚ÇÅ))
          w'' (AST.NBS-publishVal! x x‚ÇÅ) = nothing -- TODO: properly handle as imposible! 


          w : Stmnt (foldLinked' ss) ‚Üí MMM (StatementsPC ss)
          w (AST.bindingS (AST.BS-let (AST.ice nothing name type) x)) = w (AST.nonBindingS (AST.exprNBS {!!}))
          w (AST.bindingS (AST.BS-let (AST.ice (just x‚ÇÅ) name type) x)) = []L -- TODO: properly handle as imposible! 
          w (AST.bindingS (AST.BS-publish! p x)) = []L -- TODO: properly handle as imposible! 
          w (AST.nonBindingS (AST.stmntNBS x)) with (w'' x)
          ... | nothing = []L
          ... | just x‚ÇÅ = guardMM _ {!!} (mkGuard ss) x‚ÇÅ ‚à∑L []L
          w (AST.nonBindingS (AST.exprNBS x)) = {!x!}
          
      sliceMM ss (h ‚à∑L (h‚ÇÅ ‚à∑L x)) =
         let q = sliceMM ss (h ‚à∑L []L)
             ss' = Category._‚ãÜ_ STMNTS (ss , refl) ((h ‚à∑L []L) , refl)
             q' = sliceMM (fst ss') (subst (Linked' bindingMechanics') (snd ss') (h‚ÇÅ ‚à∑L x))
             z = (Category._‚ãÜ_ CC (q , {!!}) (q' , refl ))
         in fst z

        where
          open FreeCategory (publicBinding {A = Unit})
      -- popMM : Statements (con [] nothing) ‚Üí Maybe {!!}
      -- popMM = {!!}

      MMM' = MMM PC[]

      mkMM : Statements (con [] nothing) ‚Üí MMM'
      mkMM = sliceMM []L

      countStates : ‚àÄ {A} ‚Üí ‚àÄ pc ‚Üí AMM A pc ‚Üí ‚Ñï
      countStates pc []L = zero
      countStates pc (guardMM _ _ x‚ÇÅ x‚ÇÇ ‚à∑L x) = suc (countStates _ x)
      countStates pc (branchMM x‚ÇÅ h h‚ÇÅ ‚à∑L x) =   countStates _ h ‚Ñï+ countStates _ h‚ÇÅ ‚Ñï+ countStates _ x


      MMM‚ÜíNMM-h : ‚Ñï ‚Üí ‚àÄ pc ‚Üí MMM pc ‚Üí NMM pc
      MMM‚ÜíNMM-h _ _ []L = []L
      MMM‚ÜíNMM-h k pc (guardMM _ x‚ÇÅ x‚ÇÇ y@(withdrawA x‚ÇÉ) ‚à∑L x) = (guardMM k x‚ÇÅ x‚ÇÇ y ‚à∑L MMM‚ÜíNMM-h (suc k) _ x)
      MMM‚ÜíNMM-h k pc (guardMM _ x‚ÇÅ x‚ÇÇ y@(depositA x‚ÇÉ) ‚à∑L x) = (guardMM k x‚ÇÅ x‚ÇÇ y ‚à∑L MMM‚ÜíNMM-h (suc k) _ x)
      MMM‚ÜíNMM-h k pc (guardMM _ x‚ÇÅ x‚ÇÇ y@(publishA x‚ÇÉ x‚ÇÑ) ‚à∑L x) = (guardMM k x‚ÇÅ x‚ÇÇ y ‚à∑L MMM‚ÜíNMM-h (suc k) _ x)
      MMM‚ÜíNMM-h k pc (branchMM x‚ÇÅ x‚ÇÇ x‚ÇÉ ‚à∑L x) =
         let b1 = MMM‚ÜíNMM-h k pc x‚ÇÇ
             b2 = MMM‚ÜíNMM-h (countStates _ x‚ÇÇ ‚Ñï+ k) pc x‚ÇÉ
          in (branchMM x‚ÇÅ b1 b2 ‚à∑L {!MMM‚ÜíNMM-h (countStates _ x‚ÇÇ ‚Ñï+ countStates _ x‚ÇÉ) _ x!})
            
      MMM‚ÜíNMM : ‚àÄ pc ‚Üí MMM pc ‚Üí NMM pc
      MMM‚ÜíNMM = MMM‚ÜíNMM-h 0



      record StateInfo  : Type‚ÇÄ where
        field
          stateContext : PublicContext
          action : Action stateContext
          caller : DishonestParticipantId
          


      record ReachFoldState : Type‚ÇÄ where
        field
          openStates : List ‚Ñï
          statesInfo : List (‚Ñï √ó (StateInfo)) 
          computed : ‚Ñï ‚Üí List (‚Ñï)

      open ReachFoldState

      initReachFoldState : ReachFoldState
      openStates initReachFoldState = []
      statesInfo initReachFoldState = []
      computed initReachFoldState = const []

      openState : ‚Ñï ‚Üí StateInfo ‚Üí ReachFoldState ‚Üí ReachFoldState
      openStates (openState x y x‚ÇÅ) = x ‚à∑ (openStates x‚ÇÅ) 
      statesInfo (openState x y x‚ÇÅ) = (x , y) ‚à∑ statesInfo x‚ÇÅ
      computed (openState x y x‚ÇÅ) = computed x‚ÇÅ


      
      _isIn_ : ‚Ñï ‚Üí List ‚Ñï ‚Üí ùüö
      x isIn [] = false
      x isIn (x‚ÇÅ ‚à∑ x‚ÇÇ) = x isIn x‚ÇÇ or Dec‚ÜíBool (discrete‚Ñï x x‚ÇÅ)

      _Li‚à™_ : List ‚Ñï ‚Üí List ‚Ñï ‚Üí List ‚Ñï
      [] Li‚à™ x‚ÇÅ = x‚ÇÅ
      (x ‚à∑ xs) Li‚à™ y =
         Cubical.Data.Bool.if x isIn y
           then xs Li‚à™ y
           else x ‚à∑ xs Li‚à™ y

      _Li‚à™'_ : ‚àÄ {A : Type‚ÇÄ} ‚Üí List (‚Ñï √ó A) ‚Üí List (‚Ñï √ó A) ‚Üí List (‚Ñï √ó A)
      [] Li‚à™' x‚ÇÅ = x‚ÇÅ
      (x ‚à∑ xs) Li‚à™' y =
        Cubical.Data.Bool.if proj‚ÇÅ x isIn map-List proj‚ÇÅ y
           then xs Li‚à™' y
           else x ‚à∑ xs Li‚à™' y


      registerState : ‚Ñï ‚Üí ReachFoldState ‚Üí ReachFoldState
      openStates (registerState x x‚ÇÅ) = (openStates x‚ÇÅ)
      statesInfo (registerState x x‚ÇÅ) = statesInfo x‚ÇÅ 
      computed (registerState x x‚ÇÅ) k =
        Cubical.Data.Bool.if k isIn (openStates x‚ÇÅ)
         then x ‚à∑ computed x‚ÇÅ k
         else computed x‚ÇÅ k


      convergeRFS : ReachFoldState ‚Üí ReachFoldState ‚Üí ReachFoldState
      openStates (convergeRFS rfsA rfsB) = (openStates rfsA) Li‚à™ (openStates rfsB)
      statesInfo (convergeRFS rfsA rfsB) = statesInfo rfsA Li‚à™' statesInfo rfsB
      computed (convergeRFS rfsA rfsB) k =
          computed rfsA k Li‚à™ computed rfsB k

      closeAll : ReachFoldState ‚Üí ReachFoldState
      openStates (closeAll x) = []
      statesInfo (closeAll x) = statesInfo x
      computed (closeAll x) = computed x

      reachability' : ReachFoldState ‚Üí ‚àÄ pc ‚Üí NMM pc ‚Üí ReachFoldState

      reachabilityStep : ReachFoldState ‚Üí ‚àÄ pc ‚Üí MM ‚Ñï pc ‚Üí ReachFoldState
      reachabilityStep rfs pc (guardMM x x‚ÇÅ x‚ÇÇ x‚ÇÉ) =
         openState x si (closeAll rfs)
         where
           si : StateInfo
           StateInfo.stateContext si = pc
           StateInfo.action si = x‚ÇÉ
           StateInfo.caller si = x‚ÇÅ
      reachabilityStep rfs pc (branchMM x x‚ÇÅ x‚ÇÇ) =
         convergeRFS (reachability' rfs pc x‚ÇÅ) (reachability' rfs pc x‚ÇÇ) 


      reachability' rfs pc []L = rfs
      reachability' rfs pc (h ‚à∑L x) = reachability' (reachabilityStep rfs _ h) _ x


      reachability : ‚àÄ pc ‚Üí NMM pc ‚Üí ReachFoldState
      reachability = reachability' initReachFoldState




      -- record TranslationReady : Type‚ÇÄ where
      --   field
      --     numberOfStates : ‚Ñï
      --   StateId = Fin (numberOfStates)

      --   field
      --     stateInfo : StateId ‚Üí StateInfo
        
          
      --   field
      --     reachableStates : (sId : StateId)  -- ‚Üí (Œì : Rec (stateContext sId))
      --           ‚Üí List (StateId √ó PCExpr (stateContext (stateInfo sId)) Bool)


      -- open StateInfo
      

      -- record TranslationReady : Type‚ÇÄ where
      --   field
      --     numberOfStates : ‚Ñï
      --   StateId = Fin (numberOfStates)

      --   field
      --     stateInfo : StateId ‚Üí StateInfo
        
          
      --   field
      --     reachableStates : (sId : StateId)  -- ‚Üí (Œì : Rec (stateContext sId))
      --           ‚Üí List (StateId √ó PCExpr (stateContext (stateInfo sId)) Bool)


      -- open TranslationReady

      -- countStates : ‚àÄ pc ‚Üí MMM pc ‚Üí ‚Ñï
      -- countStates pc []L = zero
      -- countStates pc (guardMM _ x‚ÇÅ x‚ÇÇ ‚à∑L x) = suc (countStates _ x)
      -- countStates pc (branchMM x‚ÇÅ h h‚ÇÅ ‚à∑L x) =   countStates _ h ‚Ñï+ countStates _ h‚ÇÅ ‚Ñï+ countStates _ x

      -- mkStateInfo : ‚àÄ pc ‚Üí (x : MMM pc) ‚Üí Fin (countStates pc x) ‚Üí StateInfo
      -- mkStateInfo pc []L = empty-rec ‚àò ¬¨Fin0
      -- mkStateInfo pc (guardMM z x‚ÇÇ x‚ÇÉ ‚à∑L x) =
      --    sum-rec (Œª x‚ÇÅ ‚Üí record { stateContext = pc ; action = x‚ÇÉ ; caller = z })
      --    (Œª x‚ÇÅ ‚Üí mkStateInfo _ x (fst x‚ÇÅ)) ‚àò fsplit
      -- mkStateInfo pc (branchMM x‚ÇÇ x‚ÇÉ x‚ÇÑ ‚à∑L x) x‚ÇÅ = {!!}

      -- digForStates : {!!}
      -- digForStates = {!!}

      -- mkReachableStates : ‚àÄ pc ‚Üí (mmm : MMM pc) ‚Üí (sId : Fin (countStates pc mmm))
      --      ‚Üí List (Fin (countStates pc mmm) √ó PCExpr (stateContext (mkStateInfo pc mmm sId)) Bool)
      -- mkReachableStates pc []L = empty-rec ‚àò ¬¨Fin0
      -- mkReachableStates pc (guardMM z x x‚ÇÅ ‚à∑L mmm) sId = {!!}
      -- mkReachableStates pc (branchMM x x‚ÇÅ x‚ÇÇ ‚à∑L mmm) sId = {!!}

      -- MMM'‚ÜíTR : MMM' ‚Üí TranslationReady
      -- numberOfStates (MMM'‚ÜíTR x) = countStates _ x
      -- stateInfo (MMM'‚ÜíTR x) = mkStateInfo _ x
      -- reachableStates (MMM'‚ÜíTR x) = {!!}

      -- -- --   OpenStates : Type‚ÇÄ
      -- -- --   OpenStates = List (StateId)

      -- -- -- open TranslationReady


      -- -- -- emptyTranslationReady : TranslationReady
      -- -- -- numberOfStates emptyTranslationReady = zero
      -- -- -- stateInfo emptyTranslationReady = empty-rec ‚àò ¬¨Fin0
      -- -- -- reachableStates emptyTranslationReady _ = []
      
      -- -- -- TRS = Œ£ TranslationReady OpenStates

      -- -- -- compTRS : List TRS ‚Üí TRS ‚Üí TRS
      -- -- -- compTRS hs t = {!!}

      -- -- -- postulate never : Empty 


      -- -- -- {-# TERMINATING #-}
      -- -- -- foldTR : Statements (con [] nothing) ‚Üí TranslationReady

      -- -- -- foldTRB : ‚àÄ {Œ§} ‚Üí (s : Stmnt (con [] nothing))
      -- -- --           ‚Üí (bd : Body (bindingMechanics' _ s ) Œ§)
      -- -- --           ‚Üí IsEmpty ‚ü® IsPureE (body (AST.bodyR (s ‚à∑L (stmnts bd)) (expr bd))) ‚ü© 
      -- -- --           ‚Üí TRS

      -- -- -- foldTRE : ‚àÄ {Œ§} ‚Üí (e : Expr (con [] nothing) Œ§)
      -- -- --           ‚Üí IsEmpty ‚ü® IsPureE e ‚ü© 
      -- -- --           ‚Üí TRS


      -- -- -- foldTR []L = emptyTranslationReady
      -- -- -- foldTR (h ‚à∑L x) with proj‚ÇÅ (snd (IsPureS h))
      -- -- -- ... | no ¬¨p = fst (foldTRB h (AST.bodyR x (lit tt)) (¬¨p ‚àò proj‚ÇÅ ‚àò proj‚ÇÅ))
      -- -- -- ... | yes p with h
      -- -- -- ... | AST.bindingS (AST.BS-let ce x‚ÇÅ) =
      -- -- --             let y = (substOneStmnts (inl (evalPureExpr x‚ÇÅ p)) (mkStatements* x))
      -- -- --             in foldTR y
      -- -- -- ... | AST.nonBindingS x‚ÇÅ = foldTR x


      -- -- -- foldTRB {Œ§} (AST.bindingS (AST.BS-let ce x‚ÇÅ)) bo@(AST.bodyR stmnts‚ÇÅ expr‚ÇÅ) xx with (proj‚ÇÅ (snd (IsPureE x‚ÇÅ)))
      -- -- -- ... | yes p =
      -- -- --    let v = evalPureExpr x‚ÇÅ p
      -- -- --    in foldTRE ((substOneExpr (inl v) (body bo))) Œª _ ‚Üí never
      -- -- -- ... | no ¬¨p with (proj‚ÇÅ (snd (IsPureE (body bo))))
      -- -- -- ... | yes p = {!!}
      -- -- -- ... | no ¬¨p‚ÇÅ = {!!}

      -- -- -- foldTRB (AST.bindingS (AST.BS-publish! p (AST.psof name {()}))) (AST.bodyR stmnts‚ÇÅ expr‚ÇÅ) x‚ÇÅ

      -- -- -- foldTRB s@(AST.nonBindingS y) bo@(AST.bodyR stmnts‚ÇÅ expr‚ÇÅ) xx with (proj‚ÇÅ (snd (IsPureS s))) | (proj‚ÇÅ (snd (IsPureE (body bo)))) 
      -- -- -- ... | yes p | _ = {!!}
      -- -- -- ... | no ¬¨p | yes p = {!!}
      -- -- -- ... | no ¬¨p | no ¬¨p‚ÇÅ = {!!}

  
      -- -- -- foldTRE e x = {!!}


